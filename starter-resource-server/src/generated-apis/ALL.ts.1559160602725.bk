
import {
    Request,
    Response,
    NextFunction,
    Router,
    Application
} from 'express';
import mongoose, { Document, Query } from 'mongoose';
import { ObjectID } from 'mongodb';
        
const ObjectId = mongoose.Schema.Types.ObjectId;
const Mixed = mongoose.Schema.Types.Mixed;



/**********     USER     **********/


import {
    User,
    UserCreateInput,
    UserChangesInput,
    UserUpdateInput,
    pickUserCreateInput,
    pickUserChangesInput,
    UserModel,
} from '../types';

/**
 * Utilitaries
 */

export function UserFindMany(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return UserModel.find(conditions, projection, options);
}
export function UserFindManyLean(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return UserFindMany(conditions, projection, options).lean();
}
export function UserFindManyExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindMany(conditions, projection, options).exec(cb);
}
export function UserFindManyLeanExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindManyLean(conditions, projection, options).exec(cb);
}

export function UserFindOne(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return UserModel.findOne(conditions, projection, options);
}
export function UserFindOneLean(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return UserFindOne(conditions, projection, options).lean();
}
export function UserFindOneExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindOne(conditions, projection, options).exec(cb);
}
export function UserFindOneLeanExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindOneLean(conditions, projection, options).exec(cb);
}

export function UserFindById(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return UserModel.findById(id, projection, options);
}
export function UserFindByIdLean(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return UserFindById(id, projection, options).lean();
}
export function UserFindByIdExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindById(id, projection, options).exec(cb);
}
export function UserFindByIdLeanExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdLean(id, projection, options).exec(cb);
}

export function UserCreate(unsafeCreateInput: UserCreateInput) {
    const createInput = pickUserCreateInput(unsafeCreateInput);
    const model = new UserModel(createInput);
    return model.save();
}
export async function UserCreateLean(createInput: UserCreateInput) {
    const object = await UserCreate(createInput);
    return object.toObject();
}

export function UserFindByIdAndUpdate(
    { id, changes: unsafeChanges }: UserUpdateInput,
    options: any = { new: true, useFindAndModify: false }
) {
    const changes = pickUserChangesInput(unsafeChanges);
    return UserModel.findByIdAndUpdate(id, { $set: changes }, options);
}
export function UserFindByIdAndUpdateLean(
    update: UserUpdateInput,
    options: any = { new: true, useFindAndModify: false }
) {
    return UserFindByIdAndUpdate(update, options).lean();
}
export function UserFindByIdAndUpdateExec(
    update: UserUpdateInput,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndUpdate(update, options).exec(cb);
}
export function UserFindByIdAndUpdateLeanExec(
    update: UserUpdateInput,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndUpdateLean(update, options).exec(cb);
}

export function UserFindByIdAndRemove(
    id: string | ObjectID,
    options: any = {}
) {
    return UserModel.findByIdAndRemove(id, options);
}
export function UserFindByIdAndRemoveLean(
    id: string | ObjectID,
    options: any = {}
) {
    return UserFindByIdAndRemove(id, options).lean();
}
export function UserFindByIdAndRemoveExec(
    id: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndRemove(id, options).exec(cb);
}
export function UserFindByIdAndRemoveLeanExec(
    id: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndRemoveLean(id, options).exec(cb);
}


export function UserFindByIdPopulateRoles(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return UserModel.findById(id, projection, options).populate('roles');
}
export function UserFindByIdPopulateRolesLean(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return UserFindByIdPopulateRoles(id, projection, options).lean();
}
export function UserFindByIdPopulateRolesExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdPopulateRoles(id, projection, options).exec(cb);
}
export function UserFindByIdPopulateRolesLeanExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdPopulateRolesLean(id, projection, options).exec(cb);
}

export async function UserFindByIdRoles(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
) {
    const object = await UserFindByIdPopulateRolesLeanExec(id, projection, options);
    return object ? object.roles : undefined;
}

export function UserFindByIdAndAddRoles(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false }
) {
    return UserModel.findByIdAndUpdate(id, { $push: { roles: addId } }, options);
}
export function UserFindByIdAndAddRolesLean(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false }
) {
    return UserFindByIdAndAddRoles(id, addId, options).lean();
}
export function UserFindByIdAndAddRolesExec(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndAddRoles(id, addId, options).exec(cb);
}
export function UserFindByIdAndAddRolesLeanExec(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndAddRolesLean(id, addId, options).exec(cb);
}

export function UserFindByIdAndRemoveRoles(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {}
) {
    return UserModel.findByIdAndUpdate(id, { $pull: { roles: removeId } }, options);
}
export function UserFindByIdAndRemoveRolesLean(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {}
) {
    return UserFindByIdAndRemoveRoles(id, removeId, options).lean();
}
export function UserFindByIdAndRemoveRolesExec(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndRemoveRoles(id, removeId, options).exec(cb);
}
export function UserFindByIdAndRemoveRolesLeanExec(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return UserFindByIdAndRemoveRolesLean(id, removeId, options).exec(cb);
}


/**
 * Middlewares
 */

export function getAllUserMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        try {
            attachCTX(req, 'getAllUser', await UserFindManyLeanExec());
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function getByIdUserMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            attachCTX(req, 'getByIdUser', await UserFindByIdLeanExec(id));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function createUserMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const createInput: UserCreateInput = req.body;
        try {
            attachCTX(req, 'createUser', await UserCreateLean(createInput));            
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function updateUserMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const changes: UserChangesInput = req.body;
        try {
            attachCTX(req, 'updateUser', await UserFindByIdAndUpdateLeanExec({ id, changes }));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function deleteUserMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            attachCTX(req, 'deleteUser', await UserFindByIdAndRemoveLeanExec(id));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}


export function getUserRolesMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            attachCTX(req, 'getUserRoles', await UserFindByIdRoles(id));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function addUserRolesMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: addId } = req.body;
        try {
            attachCTX(req, 'addUserRoles', await UserFindByIdAndAddRolesLeanExec(id, addId));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function removeUserRolesMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: removeId } = req.body;
        try {
            attachCTX(req, 'removeUserRoles', await UserFindByIdAndRemoveRolesLeanExec(id, removeId));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}


/**
 * Controllers
 */

export function getAllUserController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        try {
            res.json(await UserFindManyLeanExec());
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function getByIdUserController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            res.json(await UserFindByIdLeanExec(id));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function createUserController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const createInput: UserCreateInput = req.body;
        try {
            res.json(await UserCreateLean(createInput));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function updateUserController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const changes: UserChangesInput = req.body;
        try {
            res.json(await UserFindByIdAndUpdateLeanExec({ id, changes }));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function deleteUserController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            res.json(await UserFindByIdAndRemoveLeanExec(id));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}


export function getUserRolesController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            res.json(await UserFindByIdRoles(id));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function addUserRolesController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: addId } = req.body;
        try {
            res.json(await UserFindByIdAndAddRolesLeanExec(id, addId));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function removeUserRolesController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: removeId } = req.body;
        try {
            res.json(await UserFindByIdAndRemoveRolesLeanExec(id, removeId));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}



export class UserAPI {

    router = Router();
    
    constructor(middlewaresMap: { [key: string]: (req: Request, res: Response, next: NextFunction) => void } = {}) {
        this.makeAPI(middlewaresMap);
    }

    private makeAPI(middlewaresMap: { [key: string]: (req: Request, res: Response, next: NextFunction) => void } = {}) {
        this.router
            .get('/', 
                middlewaresMap.hasTokenLogMiddleware,
                getAllUserController())
            .get('/:id', 
                middlewaresMap.hasTokenLogMiddleware,
                getByIdUserController())
            .put('/:id', 
                middlewaresMap.hasTokenLogMiddleware,
                updateUserController())
            .delete('/:id', 
                middlewaresMap.hasTokenLogMiddleware,
                deleteUserController())
            .get('/:id/roles', 
                middlewaresMap.hasTokenLogMiddleware,
                getUserRolesController())
            .put('/:id/roles/add', 
                middlewaresMap.hasTokenLogMiddleware,
                addUserRolesController())
            .put('/:id/roles/remove', 
                middlewaresMap.hasTokenLogMiddleware,
                removeUserRolesController());
    }
    
    applyAPI(app: Application) {
        app.use('/users', this.router);
        console.log(`***********     ${BrightCCC}${'users'.toUpperCase()}${ResetCCC}     ***********`);
        console.log('\n');
        this.router.stack.forEach(({ route: { path, methods } }) => console.log(
            `${colorVerb(Object.keys(methods)[0].toUpperCase())} => ${colorPath('/users' + path)}`
        ));
        console.log('\n\n');
    }
}
function attachCTX(req: Request, key: string, value: any) {
    req['CTX'][key] = value;
    return value;
}

const ResetCCC = "[0m";
const BrightCCC = "[1m";
const DimCCC = "[2m";
const UnderscoreCCC = "[4m";
const BlinkCCC = "[5m";
const ReverseCCC = "[7m";
const HiddenCCC = "[8m";
const FgBlackCCC = "[30m";
const FgRedCCC = "[31m";
const FgGreenCCC = "[32m";
const FgYellowCCC = "[33m";
const FgBlueCCC = "[34m";
const FgMagentaCCC = "[35m";
const FgCyanCCC = "[36m";
const FgWhiteCCC = "[37m";
const BgBlackCCC = "[40m";
const BgRedCCC = "[41m";
const BgGreenCCC = "[42m";
const BgYellowCCC = "[43m";
const BgBlueCCC = "[44m";
const BgMagentaCCC = "[45m";
const BgCyanCCC = "[46m";
const BgWhiteCCC = "[47m";

function colorVerb(verb: string) {
    switch (verb) {
        case 'GET':
            return `${BrightCCC}${FgBlueCCC}GET${ResetCCC}`;
        case 'POST':
            return `${BrightCCC}${FgGreenCCC}POST${ResetCCC}`;
        case 'PUT':
            return `${BrightCCC}${FgYellowCCC}PUT${ResetCCC}`;
        case 'DELETE':
            return `${BrightCCC}${FgRedCCC}DELETE${ResetCCC}`;
        default:
            return verb;
    }
}
function colorPath(path: string) {
    const parts = path.split('/').slice(1);
    parts[0] = `${UnderscoreCCC}${BrightCCC}${parts[0]}${ResetCCC}${UnderscoreCCC}`;
    if (parts[1]) {
        parts[1] = `${UnderscoreCCC}${FgBlueCCC}${parts[1]}${ResetCCC}${UnderscoreCCC}`;
    }
    if (parts[2]) {
        parts[2] = `${UnderscoreCCC}${BrightCCC}${FgYellowCCC}${parts[2]}${ResetCCC}${UnderscoreCCC}`;
    }
    if (parts[3] && parts[3] === 'add') {
        parts[3] = `${UnderscoreCCC}${FgGreenCCC}${parts[3]}${ResetCCC}${UnderscoreCCC}`;
    } else if (parts[3] && parts[3] === 'remove') {
        parts[3] = `${UnderscoreCCC}${FgRedCCC}${parts[3]}${ResetCCC}${UnderscoreCCC}`;
    }
    return `${UnderscoreCCC}${parts.join('/')}${ResetCCC}`;
}

import {
    Request,
    Response,
    NextFunction,
    Router,
    Application
} from 'express';
import mongoose, { Document } from 'mongoose';
import { ObjectID } from 'mongodb';
        
const ObjectId = mongoose.Schema.Types.ObjectId;
const Mixed = mongoose.Schema.Types.Mixed;



/**********     ROLE     **********/


import {
    Role,
    RoleCreateInput,
    RoleChangesInput,
    RoleUpdateInput,
    pickRoleCreateInput,
    pickRoleChangesInput,
    RoleModel,
} from '../types';

/**
 * Utilitaries
 */

export function RoleFindMany(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return RoleModel.find(conditions, projection, options);
}
export function RoleFindManyLean(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return RoleFindMany(conditions, projection, options).lean();
}
export function RoleFindManyExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindMany(conditions, projection, options).exec(cb);
}
export function RoleFindManyLeanExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindManyLean(conditions, projection, options).exec(cb);
}

export function RoleFindOne(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return RoleModel.findOne(conditions, projection, options);
}
export function RoleFindOneLean(
    conditions: any = {},
    projection?: any,
    options: any = {}
) {
    return RoleFindOne(conditions, projection, options).lean();
}
export function RoleFindOneExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindOne(conditions, projection, options).exec(cb);
}
export function RoleFindOneLeanExec(
    conditions: any = {},
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindOneLean(conditions, projection, options).exec(cb);
}

export function RoleFindById(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return RoleModel.findById(id, projection, options);
}
export function RoleFindByIdLean(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return RoleFindById(id, projection, options).lean();
}
export function RoleFindByIdExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindById(id, projection, options).exec(cb);
}
export function RoleFindByIdLeanExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdLean(id, projection, options).exec(cb);
}

export function RoleCreate(unsafeCreateInput: RoleCreateInput) {
    const createInput = pickRoleCreateInput(unsafeCreateInput);
    const model = new RoleModel(createInput);
    return model.save();
}
export async function RoleCreateLean(createInput: RoleCreateInput) {
    const object = await RoleCreate(createInput);
    return object.toObject();
}

export function RoleFindByIdAndUpdate(
    { id, changes: unsafeChanges }: RoleUpdateInput,
    options: any = { new: true, useFindAndModify: false }
) {
    const changes = pickRoleChangesInput(unsafeChanges);
    return RoleModel.findByIdAndUpdate(id, { $set: changes }, options);
}
export function RoleFindByIdAndUpdateLean(
    update: RoleUpdateInput,
    options: any = { new: true, useFindAndModify: false }
) {
    return RoleFindByIdAndUpdate(update, options).lean();
}
export function RoleFindByIdAndUpdateExec(
    update: RoleUpdateInput,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndUpdate(update, options).exec(cb);
}
export function RoleFindByIdAndUpdateLeanExec(
    update: RoleUpdateInput,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndUpdateLean(update, options).exec(cb);
}

export function RoleFindByIdAndRemove(
    id: string | ObjectID,
    options: any = {}
) {
    return RoleModel.findByIdAndRemove(id, options);
}
export function RoleFindByIdAndRemoveLean(
    id: string | ObjectID,
    options: any = {}
) {
    return RoleFindByIdAndRemove(id, options).lean();
}
export function RoleFindByIdAndRemoveExec(
    id: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndRemove(id, options).exec(cb);
}
export function RoleFindByIdAndRemoveLeanExec(
    id: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndRemoveLean(id, options).exec(cb);
}


export function RoleFindByIdPopulateUsers(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return RoleModel.findById(id, projection, options).populate('users');
}
export function RoleFindByIdPopulateUsersLean(
    id: string | ObjectID,
    projection?: any,
    options: any = {}
) {
    return RoleFindByIdPopulateUsers(id, projection, options).lean();
}
export function RoleFindByIdPopulateUsersExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdPopulateUsers(id, projection, options).exec(cb);
}
export function RoleFindByIdPopulateUsersLeanExec(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdPopulateUsersLean(id, projection, options).exec(cb);
}

export async function RoleFindByIdUsers(
    id: string | ObjectID,
    projection?: any,
    options: any = {},
) {
    const object = await RoleFindByIdPopulateUsersLeanExec(id, projection, options);
    return object ? object.users : undefined;
}

export function RoleFindByIdAndAddUsers(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false }
) {
    return RoleModel.findByIdAndUpdate(id, { $push: { users: addId } }, options);
}
export function RoleFindByIdAndAddUsersLean(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false }
) {
    return RoleFindByIdAndAddUsers(id, addId, options).lean();
}
export function RoleFindByIdAndAddUsersExec(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndAddUsers(id, addId, options).exec(cb);
}
export function RoleFindByIdAndAddUsersLeanExec(
    id: string | ObjectID,
    addId: string | ObjectID,
    options: any = { new: true, useFindAndModify: false },
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndAddUsersLean(id, addId, options).exec(cb);
}

export function RoleFindByIdAndRemoveUsers(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {}
) {
    return RoleModel.findByIdAndUpdate(id, { $pull: { users: removeId } }, options);
}
export function RoleFindByIdAndRemoveUsersLean(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {}
) {
    return RoleFindByIdAndRemoveUsers(id, removeId, options).lean();
}
export function RoleFindByIdAndRemoveUsersExec(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndRemoveUsers(id, removeId, options).exec(cb);
}
export function RoleFindByIdAndRemoveUsersLeanExec(
    id: string | ObjectID,
    removeId: string | ObjectID,
    options: any = {},
    cb?: (err: any, result: any) => void
) {
    return RoleFindByIdAndRemoveUsersLean(id, removeId, options).exec(cb);
}


/**
 * Middlewares
 */

export function getAllRoleMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        try {
            attachCTX(req, 'getAllRole', await RoleFindManyLeanExec());
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function getByIdRoleMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            attachCTX(req, 'getByIdRole', await RoleFindByIdLeanExec(id));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function createRoleMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const createInput: RoleCreateInput = req.body;
        try {
            attachCTX(req, 'createRole', await RoleCreateLean(createInput));            
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function updateRoleMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const changes: RoleChangesInput = req.body;
        try {
            attachCTX(req, 'updateRole', await RoleFindByIdAndUpdateLeanExec({ id, changes }));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function deleteRoleMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            attachCTX(req, 'deleteRole', await RoleFindByIdAndRemoveLeanExec(id));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}


export function getRoleUsersMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            attachCTX(req, 'getRoleUsers', await RoleFindByIdUsers(id));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function addRoleUsersMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: addId } = req.body;
        try {
            attachCTX(req, 'addRoleUsers', await RoleFindByIdAndAddUsersLeanExec(id, addId));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}
export function removeRoleUsersMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: removeId } = req.body;
        try {
            attachCTX(req, 'removeRoleUsers', await RoleFindByIdAndRemoveUsersLeanExec(id, removeId));
        } catch(error) {
            return res.status(400).json({ message: 'Something went wrong.', error });
        }
        next();
    };
}


/**
 * Controllers
 */

export function getAllRoleController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        try {
            res.json(await RoleFindManyLeanExec());
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function getByIdRoleController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            res.json(await RoleFindByIdLeanExec(id));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function createRoleController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const createInput: RoleCreateInput = req.body;
        try {
            res.json(await RoleCreateLean(createInput));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function updateRoleController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const changes: RoleChangesInput = req.body;
        try {
            res.json(await RoleFindByIdAndUpdateLeanExec({ id, changes }));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function deleteRoleController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            res.json(await RoleFindByIdAndRemoveLeanExec(id));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}


export function getRoleUsersController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        try {
            res.json(await RoleFindByIdUsers(id));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function addRoleUsersController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: addId } = req.body;
        try {
            res.json(await RoleFindByIdAndAddUsersLeanExec(id, addId));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}
export function removeRoleUsersController() {
    return async (req: Request, res: Response, next: NextFunction) => {
        const id = req.params.id;
        const { id: removeId } = req.body;
        try {
            res.json(await RoleFindByIdAndRemoveUsersLeanExec(id, removeId));
        } catch(error) {
            res.status(400).json({ message: 'Something went wrong.', error });
        }
    };
}



export class RoleAPI {

    router = Router();
    
    constructor(middlewaresMap: { [key: string]: (req: Request, res: Response, next: NextFunction) => void } = {}) {
        this.makeAPI(middlewaresMap);
    }

    private makeAPI(middlewaresMap: { [key: string]: (req: Request, res: Response, next: NextFunction) => void } = {}) {
        this.router
            .get('/', getAllRoleController())
            .post('/', createRoleController())
            .delete('/:id', deleteRoleController())
            .get('/:id/users', getRoleUsersController())
            .put('/:id/users/remove', removeRoleUsersController());
    }
    
    applyAPI(app: Application) {
        app.use('/roles', this.router);
        console.log(`***********     ${BrightCCC}${'roles'.toUpperCase()}${ResetCCC}     ***********`);
        console.log('\n');
        this.router.stack.forEach(({ route: { path, methods } }) => console.log(
            `${colorVerb(Object.keys(methods)[0].toUpperCase())} => ${colorPath('/roles' + path)}`
        ));
        console.log('\n\n');
    }
}
function attachCTX(req: Request, key: string, value: any) {
    req['CTX'][key] = value;
    return value;
}

const ResetCCC = "[0m";
const BrightCCC = "[1m";
const DimCCC = "[2m";
const UnderscoreCCC = "[4m";
const BlinkCCC = "[5m";
const ReverseCCC = "[7m";
const HiddenCCC = "[8m";
const FgBlackCCC = "[30m";
const FgRedCCC = "[31m";
const FgGreenCCC = "[32m";
const FgYellowCCC = "[33m";
const FgBlueCCC = "[34m";
const FgMagentaCCC = "[35m";
const FgCyanCCC = "[36m";
const FgWhiteCCC = "[37m";
const BgBlackCCC = "[40m";
const BgRedCCC = "[41m";
const BgGreenCCC = "[42m";
const BgYellowCCC = "[43m";
const BgBlueCCC = "[44m";
const BgMagentaCCC = "[45m";
const BgCyanCCC = "[46m";
const BgWhiteCCC = "[47m";

function colorVerb(verb: string) {
    switch (verb) {
        case 'GET':
            return `${BrightCCC}${FgBlueCCC}GET${ResetCCC}`;
        case 'POST':
            return `${BrightCCC}${FgGreenCCC}POST${ResetCCC}`;
        case 'PUT':
            return `${BrightCCC}${FgYellowCCC}PUT${ResetCCC}`;
        case 'DELETE':
            return `${BrightCCC}${FgRedCCC}DELETE${ResetCCC}`;
        default:
            return verb;
    }
}
function colorPath(path: string) {
    const parts = path.split('/').slice(1);
    parts[0] = `${UnderscoreCCC}${BrightCCC}${parts[0]}${ResetCCC}${UnderscoreCCC}`;
    if (parts[1]) {
        parts[1] = `${UnderscoreCCC}${FgBlueCCC}${parts[1]}${ResetCCC}${UnderscoreCCC}`;
    }
    if (parts[2]) {
        parts[2] = `${UnderscoreCCC}${BrightCCC}${FgYellowCCC}${parts[2]}${ResetCCC}${UnderscoreCCC}`;
    }
    if (parts[3] && parts[3] === 'add') {
        parts[3] = `${UnderscoreCCC}${FgGreenCCC}${parts[3]}${ResetCCC}${UnderscoreCCC}`;
    } else if (parts[3] && parts[3] === 'remove') {
        parts[3] = `${UnderscoreCCC}${FgRedCCC}${parts[3]}${ResetCCC}${UnderscoreCCC}`;
    }
    return `${UnderscoreCCC}${parts.join('/')}${ResetCCC}`;
}

import {
    Request,
    Response,
    NextFunction,
    Router,
    Application
} from 'express';
import mongoose, { Document } from 'mongoose';
import { ObjectID } from 'mongodb';
        
const ObjectId = mongoose.Schema.Types.ObjectId;
const Mixed = mongoose.Schema.Types.Mixed;



/**********     USER     **********/


//  
// Base entity interface
//

export interface User {
    _id: string;
    username: string;
    password: string;
    roles?: [Role];
}
            
//  
// Input payload interface for entity creation
//

export interface UserCreateInput {
    _id?: string,
    username: string;
    password: string;
}

//
// Function used to pick only needed properties
//

export function pickUserCreateInput<T extends { _id?: string|ObjectID }>(input: T) {
    if (input._id !== undefined
        && input._id !== null
    ) {
        input._id = typeof(input._id) === 'string' ? new ObjectID(input._id) : input._id;
    }
    return ['username','password'].reduce((createInput, key) => {
        createInput[key] = input[key];
        return createInput;
    }, {}) as UserCreateInput;
}
            
//  
// Input payload interface for entity update
//

export interface UserChangesInput {
    username?: string;
    password?: string;
}

//
// Function used to pick only needed properties
//

export function pickUserChangesInput<T extends {}>(input: T) {
    return ['username','password'].reduce((changesInput, key) => {
        changesInput[key] = input[key];
        return changesInput;
    }, {}) as UserChangesInput;
}

export interface UserUpdateInput {
    id: string;
    changes: UserChangesInput;
}
            
//  
// Mongoose Schema/Model for this entity
//

export const UserSchema = new mongoose.Schema(
    {
        username: {
            type: String,
            required: true,
            unique: true,
        },
        password: {
            type: String,
            required: true,
        },
        roles: [{
            type: ObjectId,
            ref: 'Role',
        }],
    },
    {
        minimize: false,
    }
);
export const UserModel = mongoose.model<Document & User>('User', UserSchema);

/**********     ROLE     **********/


//  
// Base entity interface
//

export interface Role {
    _id: string;
    name: string;
    users?: [User];
}
            
//  
// Input payload interface for entity creation
//

export interface RoleCreateInput {
    _id?: string,
    name: string;
}

//
// Function used to pick only needed properties
//

export function pickRoleCreateInput<T extends { _id?: string|ObjectID }>(input: T) {
    if (input._id !== undefined
        && input._id !== null
    ) {
        input._id = typeof(input._id) === 'string' ? new ObjectID(input._id) : input._id;
    }
    return ['name'].reduce((createInput, key) => {
        createInput[key] = input[key];
        return createInput;
    }, {}) as RoleCreateInput;
}
            
//  
// Input payload interface for entity update
//

export interface RoleChangesInput {
    name?: string;
}

//
// Function used to pick only needed properties
//

export function pickRoleChangesInput<T extends {}>(input: T) {
    return ['name'].reduce((changesInput, key) => {
        changesInput[key] = input[key];
        return changesInput;
    }, {}) as RoleChangesInput;
}

export interface RoleUpdateInput {
    id: string;
    changes: RoleChangesInput;
}
            
//  
// Mongoose Schema/Model for this entity
//

export const RoleSchema = new mongoose.Schema(
    {
        name: {
            type: String,
            required: true,
            unique: true,
        },
        users: [{
            type: ObjectId,
            ref: 'User',
        }],
    },
    {
        minimize: false,
    }
);
export const RoleModel = mongoose.model<Document & Role>('Role', RoleSchema);